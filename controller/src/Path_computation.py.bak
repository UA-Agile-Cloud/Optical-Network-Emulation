"""
Intra_domain path computation 

Author:   Yao Li (yaoli@optics.arizona.edu.cn)
          Yiwen Shen (ys2799@columbia.edu)
Created:  2017/01/09
Version:  1.0

Last modified by Yao: 2017/05/19

"""

from ryu.base import app_manager
from ryu.controller.handler import set_ev_cls
import time
from Common import *
import Database
import Custom_event
import logging
#from rwa_core import *
import RWA_shortestpath_random as RWA
from Common import log_level
import scipy.constants as sc
import generate_rules
#import remote_mininet_client
from time import sleep
import random

logging.basicConfig(level = log_level)

class Path_computation(app_manager.RyuApp):
    
    _EVENTS =  [Custom_event.IntraDomainPathCompRequestEvent,
                Custom_event.IntraDomainPathCompReplyEvent,
                Custom_event.CrossDomainPathCompRequestEvent,
                Custom_event.CrossDomainPathCompReplyEvent,
                Custom_event.CrossDomainReroutingRequestEvent,
                Custom_event.CrossDomainReroutingReplyEvent,
                Custom_event.EastWest_SendPathCompRequestEvent,
                Custom_event.EastWest_ReceivePathCompRequestEvent,
                Custom_event.EastWest_SendPathCompReplyEvent,
                Custom_event.EastWest_ReceivePathCompReplyEvent,
                Custom_event.IntraDomainReroutingRequest,
                Custom_event.IntraDomainReroutingReply]
                
    def __init__(self,*args,**kwargs):
        super(Path_computation, self).__init__(*args,**kwargs)
        # for OSNR estimation purposes
        self.flow_id = 0
        # Converting 0.2dB loss, and multiplying
        # for 60km.
        self.abs_fiber_loss = self.dB_to_abs(0.2*60)
        # Converting 6dB loss
        self.abs_WSS_loss = self.dB_to_abs(9) # constant

    @set_ev_cls(Custom_event.IntraDomainPathCompRequestEvent)
    def _handle_intra_domain_traffic_pc_request(self,ev): 
        """Path computation of a intra-domain traffic
        """
        Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION)     # update traffic state to path_computation
        traf = Database.Data.traf_list.find_traf_by_id(ev.traf_id)
        if (traf == None):
            self.logger.info('Can not find traf_id in database! (intra_domain_path_domputation: _handle_intra_domain_traffic_pc_request)')
            return
        if (traf.prot_type == TRAFFIC_NO_PROTECTION or traf.prot_type == TRAFFIC_REROUTING_RESTORATION): 
            #source_node_id = Database.Data.phy_topo.get_node_id_by_ip(traf.src_node_ip)
            #destination_node_id = Database.Data.phy_topo.get_node_id_by_ip(traf.dst_node_ip)
            sources = list()
            traf_add_port_id = Database.Data.phy_topo.get_traf_add_port(traf.src_node_ip)
            print traf.src_node_ip
            if traf_add_port_id == None:
                self.logger.critical('Cannot find an add port. (Path_computation: _handle_intra_domain_traffic_pc_request)')
                print 'non-addport'
                return
            common_avai_chnls = Database.Data.phy_topo.get_traf_add_port_resouce(traf.src_node_ip, traf_add_port_id)
            if common_avai_chnls == None:
                self.logger.critical('Cannot find an add port. (Path_computation: _handle_intra_domain_traffic_pc_request)')
                print 'non-avachnls'
                return
            sources.append([traf.src_node_ip, traf_add_port_id, ROUTE_WORKING, 0, common_avai_chnls])
            destinations = list()
            traf_drop_port_id = Database.Data.phy_topo.get_traf_drop_port(traf.dst_node_ip)
            if traf_drop_port_id == None:
                self.logger.critical('Cannot find an drop port. (Path_computation: _handle_intra_domain_traffic_pc_request)')
                return
            destinations.append([traf.dst_node_ip, traf_drop_port_id])
            #paths = RWA.routing(ev.traf_id, sources, destinations, traf.bw_demand)    #routing. calculate one path
            paths = RWA.routing(ev.traf_id, sources, destinations, 50)
            print('================================================')
            # OSNR Estimation
            selected_path = paths[0][3]
            flow_id = ev.traf_id
            chnl = random.randint(1, len(common_avai_chnls)-1)
            wavelength = common_avai_chnls[chnl]
            #generate_rules.main(selected_path, wavelength, flow_id)
            #sleep(0.01)
            estimatedOSNR = self.handle_osnr_estimation(selected_path)
            a, b, c, src_node_id = str(traf.src_node_ip).split('.')
            a, b, c, dest_node_id = str(traf.dst_node_ip).split('.')
            #self.remote_mininet_client(flow_id, src_node_id, dest_node_id, wavelength)
            #sleep(0.01)
            print('================================================')
	    if (paths == None):
                #Database.Data.traf_list.update_traf_state(traf.traf_id, TRAFFIC_PATH_COMPUTATION_FAIL) 
                pc_reply_ev = Custom_event.IntraDomainPathCompReplyEvent()
                pc_reply_ev.traf_id = ev.traf_id
                pc_reply_ev.result = FAIL
                self.send_event('Intra_domain_connection_ctrl',pc_reply_ev)
                # delete traffic information
                Database.Data.traf_list.remove(traf)
            else:
                result = SUCCESS
                print paths
                for path in paths:
                    Database.Data.intra_domain_path_list.insert_a_new_path(path)    #record the result of routing
                    #print path
                resources = RWA.rsc_allocation(ev.traf_id, traf.bw_dmd)
                for path_item in resources:
                    new_path = Database.Data.intra_domain_path_list.find_a_path_by_id(path_item[0])
                    if new_path == None:
                        self.logger.critical('Cannot intra-domain path for traffic %d.' % ev.traf_id)
                        result = FAIL
                        break
                    if new_path.route_type == ROUTE_WORKING:
                        if estimatedOSNR >= OSNR_THRESHOLD:
                            Database.Data.insert_new_lsp(new_path, path_item[1])
                            current_lsp = Database.Data.lsp_list.find_lsp_by_id(ev.traf_id, Database.Data.lsp_id):
                            if current_lsp != None:
                                current_lsp.estimated_drop_OSNR = estimatedOSNR
                            else:
                                self.logger.info('Cannot find newly inserted LSP. (Path_computation: _handle_intra_domain_traffic_pc_request)')
                            with open('estimatedOSNR.txt', 'a') as f:
                                f.write(str(ev.traf_id)+'\t'+'0')
                        else:
                            result = FAIL
                    else: 
                        self.logger.critical('Wrong route type. (Path_computation: _handle_intra_domain_traffic_pc_request)')
                        return
                Database.Data.intra_domain_path_list.pop_paths(ev.traf_id)
                if result == SUCCESS:
                    Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_SUCCESS) 
                else:
                    Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_FAIL)
                """for path in paths:  
                    comm_avai_chnl = path[4]
                    resources = RWA.rsc_allocation(comm_avai_chnl, traf.bw_demand)
                    routing_path = Database.Intra_domain_path()
                    routing_path.traf_id = path[0]
                    routing_path.route_type = path[1]
                    routing_path.cost = path[2]
                    routing_path.route = []
                    for this_node in path[3]:
                        new_node = Node_for_route()
                        new_node.node_ip = this_node[0]
                        new_node.add_port_id = this_node[1]
                        new_node.add_port_power = 0
                        new_node.drop_port_id = this_node[2]
                        new_node.drop_port_power = 0
                        routing_path.route.append(new_node)
                    routing_path.chnl = list(path[4])
                    if (Database.Data.insert_new_lsp(routing_path, resources) == False):
                        self.logger.info('Insert unprovisioned lsp error!')
                        result_tmp = FAIL
                #Database.Data.traf_list.update_traf_state(traf.traf_id, TRAFFIC_PATH_COMPUTATION_SUCCESS) """
                pc_reply_ev = Custom_event.IntraDomainPathCompReplyEvent()
                pc_reply_ev.traf_id = ev.traf_id
                pc_reply_ev.result = result
                self.send_event('Intra_domain_connection_ctrl',pc_reply_ev)
        elif (ev.prot_type == TRAFFIC_1PLUS1_PROTECTION):
            pass
        else:
            self.logger.info('Protection type error! Protection type = %d' % ev.prot_type)


    @set_ev_cls(Custom_event.CrossDomainPathCompRequestEvent)
    def _handle_cross_domain_traffic_pc_request(self,ev): 
        """Path computation of a cross-domain traffic at its source domain
        """
        self.logger.debug('Path_computation module receives CrossDomainPathCompRequestEvent')
        Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION)     # update traffic state to path_computation
        traf = Database.Data.traf_list.find_traf_by_id(ev.traf_id)
        if (traf == None):
            self.logger.critical('Can not find traf_id in database! (cross_domain_path_domputation_at_src_domain)')
            return
        if (traf.prot_type == TRAFFIC_NO_PROTECTION or traf.prot_type == TRAFFIC_REROUTING_RESTORATION): 
            #source_node_id = Database.Data.phy_topo.get_node_id_by_ip(traf.src_node_ip)
            #destination_node_id = RWA.find_exit_of_this_domain(traf.domain_sequence[1])
            sources = list()
            traf_add_port_id = Database.Data.phy_topo.get_traf_add_port(traf.src_node_ip)
            if traf_add_port_id == None:
                self.logger.critical('Cannot find an add port. (Path_computation: _handle_cross_domain_traffic_pc_request)')
                return
            common_avai_chnls = Database.Data.phy_topo.get_traf_add_port_resouce(traf.src_node_ip, traf_add_port_id)
            if common_avai_chnls == None:
                self.logger.critical('Cannot find an add port. (Path_computation: _handle_cross_domain_traffic_pc_request)')
                return
            sources.append([traf.src_node_ip, traf_add_port_id, ROUTE_WORKING, 0, common_avai_chnls])
            destinations = RWA.find_exit_of_this_domain(traf.domain_sequence[1])
            if destinations == None:
                self.logger.critical('Cannot find a interlink. (Path_computation: _handle_cross_domain_traffic_pc_request)')
                return
            paths = RWA.routing(ev.traf_id, sources, destinations, traf.bw_dmd)    #routing. calculate one path
            #print '==============================='
            # from Yiwen
            #src_node_ip = traf.src_node_ip
            #src_port_id = Database.Data.phy_topo.get_port_id(src_node_ip)
            #edge_node_ip = Database.Data.phy_topo.get_edge_node_ip()
            #edge_node_id = Database.Data.phy_topo.get_edge_node_id()
            #self.logger.info ("Begin path computation in source domain from source node {0} to edge node {1}".format(src_node_ip, edge_node_ip))
            #topo = Database.Data.phy_topo.get_topo()
            #nlambda = 3
            #paths = self.routing(str(ev.traf_id), topo, nlambda, src_node_ip, src_port_id, edge_node_ip, traf.bw_dmd)    #routing. calculate one path
            # from Yiwen end
            
            # tmp routing. for temp use only
            #path = list()
            #path.append(ev.traf_id)
            #path.append(ROUTE_WORKING)
            #path.append(0)
            #path.append([['192.168.1.1',1,2],['192.168.1.2',1,2],['192.168.1.3',1,2]])
            #path.append([15])
            # tmp routing end
            
            if (paths == None):
                #Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_FAIL)
                # send pc reply event to Cross_domain_connection_ctrl
                pc_reply_ev = Custom_event.CrossDomainPathCompReplyEvent()
                pc_reply_ev.traf_id = traf.traf_id
                pc_reply_ev.result = FAIL
                self.send_event('Cross_domain_connection_ctrl', pc_reply_ev)
            else:
                for path in paths:
                    #print '.....................'                   
                    Database.Data.intra_domain_path_list.insert_a_new_path(path)    #record the result of routing
                    #print path
                entry_of_next_domain = RWA.find_entry_of_next_domain(ev.traf_id)  # find entry of next domain
                #entry_of_next_domain = []
                if entry_of_next_domain != None:
                    cross_domain_pc_ev = Custom_event.EastWest_SendPathCompRequestEvent()
                    cross_domain_pc_ev.traf_id = ev.traf_id
                    cross_domain_pc_ev.route_type = ROUTE_WORKING
                    cross_domain_pc_ev.entry_of_next_domain = entry_of_next_domain
                    self.send_event('EastWest_message_send',cross_domain_pc_ev)
                else:
                    pc_reply_ev = Custom_event.CrossDomainPathCompReplyEvent()
                    pc_reply_ev.traf_id = traf.traf_id
                    pc_reply_ev.result = FAIL
                    self.send_event('Cross_domain_connection_ctrl', pc_reply_ev)
        elif (traf.prot_type == TRAFFIC_1PLUS1_PROTECTION):
            pass
        else:
            self.logger.info('Protection type error! Protection type = %d' % ev.prot_type)

    @set_ev_cls(Custom_event.EastWest_ReceivePathCompRequestEvent)
    def _handle_cross_domain_pc_request(self,ev):
        """path computation at domains (which are not the source domain) of a cross-domain traffic
        """
        pass
        #if (traf.prot_type == TRAFFIC_1PLUS1_PROTECTION):
        #   pass
        #if ev.route_type == ROUTE_REROUTE:
        #   update traffic stage to TRAFFIC_REROUTING in database
        #path computation in this domain
        #if SUCCESS:
        #   if this domain is not the destination domain:
        #       send Custom_event.EastWest_SendPathCompRequestEvent to 'EastWest_message_send'
        #   else:
        #       do resource allocation, update Database.Data.lsp_list
        #       update traffic state in database (TRAFFIC_PATH_COMPUTATION_SUCCESS)
        #       send Custom_event.EastWest_SendPathCompReplyEvent to 'EastWest_message_send'
        #else:
        #   update traffic state in database (TRAFFIC_PATH_COMPUTATION_FAIL)
        #   send Custom_event.EastWest_SendPathCompReplyEvent to 'EastWest_message_send'
        
        self.logger.debug('Path_computation module receives EastWest_ReceivePathCompRequestEvent')
        if ev.route_type == ROUTE_REROUTE:
            Database.Data.traf_list.update_traf_stage(ev.traf_id, TRAFFIC_REROUTING)
        Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION)
        traf = Database.Data.traf_list.find_traf_by_id(ev.traf_id)
        if traf == None:
            self.logger.critical('Cannot find traffic %d. (Path_computation: _handle_cross_domain_pc_request)' % ev.traf_id)
            return
        if (traf.prot_type == TRAFFIC_NO_PROTECTION or traf.prot_type == TRAFFIC_REROUTING_RESTORATION): 
            #source_node_id = Database.Data.phy_topo.get_node_id_by_ip(ev.entry_of_next_domain[0])
            #destination_node_id = RWA.find_exit_of_this_domain(traf.domain_sequence[1])
            sources = ev.entry_of_next_domain
            if Database.Data.controller_list.is_this_domain(traf.domain_sequence[-1]) == False:
                next_domain_id = Database.Data.traf_list.find_next_domain_id(ev.traf_id, Database.Data.controller_list.this_controller.domain_id)
                destinations = RWA.find_exit_of_this_domain(next_domain_id)
                if destinations == None:
                    self.logger.critical('Cannot find a interlink. (Path_computation: _handle_cross_domain_traffic_pc_request)')
                    return
            else:
                destinations = list()
                traf_drop_port_id = Database.Data.phy_topo.get_traf_drop_port(traf.dst_node_ip)
                if traf_drop_port_id == None:
                    self.logger.critical('Cannot find an drop port. (Path_computation: _handle_cross_domain_pc_request)')
                    return
                destinations.append([traf.dst_node_ip, traf_drop_port_id])
            if ev.route_type == ROUTE_REROUTE:
                paths = RWA.rerouting(ev.traf_id, sources, destinations, traf.bw_dmd)
            else:
                paths = RWA.routing(ev.traf_id, sources, destinations, traf.bw_dmd)
            if paths == None:
                Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_FAIL)
                ew_pc_reply = Custom_event.EastWest_SendPathCompReplyEvent()
                ew_pc_reply.traf_id = ev.traf_id
                ew_pc_reply.route_type = ev.route_type
                ew_pc_reply.result = FAIL
                #ew_pc_reply.resource_allocation = []
                ew_pc_reply.exit_of_previous_domain = None
                self.send_event('EastWest_message_send', ew_pc_reply)
            else:
                for path in paths:
                    Database.Data.intra_domain_path_list.insert_a_new_path(path)    #record the result of routing
                if Database.Data.controller_list.is_this_domain(traf.domain_sequence[-1]) == False:
                    entry_of_next_domain = RWA.find_entry_of_next_domain(ev.traf_id)  # find entry of next domain
                    cross_domain_pc_ev = Custom_event.EastWest_SendPathCompRequestEvent()
                    cross_domain_pc_ev.traf_id = ev.traf_id
                    cross_domain_pc_ev.route_type = ev.route_type
                    cross_domain_pc_ev.entry_of_next_domain = entry_of_next_domain
                    self.send_event('EastWest_message_send',cross_domain_pc_ev)
                else:
                    resources = RWA.rsc_allocation(ev.traf_id, traf.bw_dmd)
                    #print '++++++++++++++++++++++++++++++++++++++'
                    print resources
                    result = SUCCESS
                    exit_of_previous_domain = list()
                    for path_item in resources:
                        new_path = Database.Data.intra_domain_path_list.find_a_path_by_id(path_item[0])
                        if new_path == None:
                            self.logger.critical('Cannot intra-domain path for traffic %d.' % ev.traf_id)
                            result = FAIL
                            break
                        Database.Data.insert_new_lsp(new_path, path_item[1])
                        print '????????????????????????'
                        print path_item[1]
                        exit_node_port_tmp = Database.Data.phy_topo.get_exit_of_previous_domain(new_path.route[0].node_ip, new_path.route[0].add_port_id)
                        if exit_node_port_tmp == None:
                            self.logger.critical('Can not find inter-domain link. (Path_computation: _handle_cross_domain_pc_request)')
                            result = FAIL
                            break
                        exit_tmp = [exit_node_port_tmp[0], exit_node_port_tmp[1], new_path.route_type, path_item[1]]
                        exit_of_previous_domain.append(exit_tmp)
                    Database.Data.intra_domain_path_list.pop_paths(ev.traf_id)
                    if result == SUCCESS:
                        Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_SUCCESS) 
                    else:
                        Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_FAIL)
                    pc_reply_ev = Custom_event.EastWest_SendPathCompReplyEvent()
                    pc_reply_ev.traf_id = ev.traf_id
                    pc_reply_ev.route_type = ev.route_type
                    pc_reply_ev.result = result
                    #pc_reply_ev.resource_allocation = list(resources)
                    if result == SUCCESS:
                        pc_reply_ev.exit_of_previous_domain = exit_of_previous_domain
                    else:
                        pc_reply_ev.exit_of_previous_domain = None
                    self.send_event('EastWest_message_send', pc_reply_ev)
        elif (traf.prot_type == TRAFFIC_1PLUS1_PROTECTION):
            pass
        else:
            self.logger.info('Protection type error! Protection type = %d' % ev.prot_type)
        

        '''tmp_time = time.time()
        # from Yiwen
        if (traf.prot_type == TRAFFIC_1PLUS1_PROTECTION):
           pass
        if ev.route_type == ROUTE_REROUTE:
        #   update traffic stage to TRAFFIC_REROUTING in database
            pass

        #path computation in this domain

        if (traf.prot_type == TRAFFIC_NO_PROTECTION or traf.prot_type == TRAFFIC_REROUTING_RESTORATION):
            self.logger.info ("Inside TRAFFIC_NO_PROTECTION regime")

            # First perform path computation to get 3 paths, and see which wavelengths are available
            src_node_ip = '192.168.2.1'
            src_port_id = Database.Data.phy_topo.get_port_id(src_node_ip)
            dst_node_ip = traf.dst_node_ip
            dst_node_id = Database.Data.phy_topo.get_node_id_by_ip(dst_node_ip)
            self.logger.info ("Begin path computation in destination domain from source node {0} to node {1}".format(src_node_ip, dst_node_ip))
            topo = Database.Data.phy_topo.get_topo()
            #print("Destination domain topology = ", topo)

            path = self.routing(str(ev.traf_id), topo, 3, src_node_ip, src_port_id, dst_node_ip, traf.bw_dmd)
            #print (path)
            if Database.Data.controller_list.this_controller.domain_id != 2:
                pass
            else:
                if (path == []):
                    self.logger.info ("Path not found")
                    #Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_FAIL)
                    # send reply message to central controller
                    # delete traffic information
                else:
                    self.logger.info ("Path found!\nIntra domain path (destination domain) = {0}".format(', '.join(map(str, path))))

                    # Find the possible wavelengths from source and dest domains
                    wavelengths_from_src=[]
                    #for i in range(0, len(ev.entry_of_next_domain)):
                        #wavelengths_from_src.append(ev.entry_of_next_domain[i][1])
                    wavelengths_from_dst=path[4]
                    self.logger.info("Possible wavelengths from source domain: {0}".format(', '.join(map(str, wavelengths_from_src))))
                    self.logger.info("Possible wavelengths from destination domain: {0}".format(', '.join(map(str, wavelengths_from_dst))))

                    # Choose lowest wavelength common to both domains
                    common_wavelengths = list(set(wavelengths_from_src) & set(wavelengths_from_dst))
                    if not common_wavelengths:
                        self.logger.info("No common wavelengths found!")
                        #Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_FAIL)
                        # send reply to central controller
                    #lowest_wavelength = common_wavelengths[0]
                    #index_of_lowest_wavelength = wavelengths_from_dst.index(lowest_wavelength)

                    # Use the lowest wavelength to find the path corresponding to that wavelength
                    #chosen_path = [path[0], path[1], path[2], path[3][index_of_lowest_wavelength], path[4][0]]
                    #self.logger.info("Chosen path: {0}".format(', '.join(map(str, chosen_path))))
                    #Database.Data.intra_domain_path_list.insert_a_new_path(chosen_path)    #record the result of routing
        # from Yiwen end
        self.logger.info('Testing! Path computation time = %s' % str(time.time() - tmp_time))'''

        #for temp use only
        '''if Database.Data.controller_list.is_this_domain(traf.domain_sequence[0]) != True:
            path = list()
            resources = None
            if ev.route_type == ROUTE_WORKING:
                path.append(ev.traf_id)
                path.append(ev.route_type)
                path.append(0)
                path.append([['192.168.2.1',1,2],['192.168.2.3',1,3]])
                path.append([15])
                Database.Data.intra_domain_path_list.insert_a_new_path(path)
                resources = [15]
            elif ev.route_type == ROUTE_REROUTE:
                path.append(ev.traf_id)
                path.append(ev.route_type)
                path.append(0)
                path.append([['192.168.2.1',1,2],['192.168.2.3',1,3]])
                path.append([30])
                Database.Data.intra_domain_path_list.insert_a_new_path(path)
                resources = [30]
            else:
                self.logger.info('Wrong route type. (Path_computation: _handle_cross_domain_pc_request)')
            path = Database.Data.intra_domain_path_list.find_a_path(ev.traf_id, ev.route_type)
            if path == None:
                self.logger.critical('Cannot intra-domain path for traffic %d.' % ev.traf_id)
                return
            Database.Data.insert_new_lsp(path, resources)
            Database.Data.intra_domain_path_list.pop_a_path(ev.traf_id, ev.route_type)
            Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_SUCCESS) 
            pc_reply_ev = Custom_event.EastWest_SendPathCompReplyEvent()
            pc_reply_ev.traf_id = ev.traf_id
            pc_reply_ev.route_type = ev.route_type
            pc_reply_ev.result = SUCCESS
            pc_reply_ev.resource_allocation = list(resources)
            self.send_event('EastWest_message_send', pc_reply_ev)
        else:
            self.logger,info('Error! This domain is the source domain. (Path_computation: _handle_cross_domain_pc_request)')
        # for temp use only end'''
        
                
     
    @set_ev_cls(Custom_event.EastWest_ReceivePathCompReplyEvent)
    def _handle_cross_domain_pc_reply(self,ev):
        """handle cross-domain path computation reply 
        """

        pass
        #if (traf.prot_type == TRAFFIC_1PLUS1_PROTECTION):
        #   pass
        #if ev.result == SUCCESS:
        #   do resource allocation, update Database.Data.lsp_list
        #   update traffic state to TRAFFIC_PATH_COMPUTATION_SUCCESS in database
        #else:
        #   update traffic state to TRAFFIC_PATH_COMPUTATION_FAIL in database  
        #if this domain is not the source domain:       
        #   send Custom_event.EastWest_SendPathCompReplyEvent to 'EastWest_message_send'
        #else:
        #   if ev.route_type == ROUTE_REROUTE:
        #       send Custom_event.CrossDomainReroutingReplyEvent to 'Cross_domain_connection_ctrl'
        #   else:
        #       send Custom_event.CrossDomainPathCompReplyEvent to 'Cross_domain_connection_ctrl'
        traf = Database.Data.traf_list.find_traf_by_id(ev.traf_id)
        if traf == None:
            self.logger.critical('Cannot find traffic %d. (Path_computation: _handle_cross_domain_pc_reply)' % ev.traf_id)
            return
        if (traf.prot_type == TRAFFIC_NO_PROTECTION or traf.prot_type == TRAFFIC_REROUTING_RESTORATION): 
            self.logger.debug('Path_computation module receives EastWest_ReceivePathCompReplyEvent')
            if ev.result == SUCCESS:
                #path = Database.Data.intra_domain_path_list.find_a_path(ev.traf_id, ev.route_type)
                paths = RWA.find_intra_domain_paths(ev.exit_of_this_domain)
                if paths == None:
                    self.logger.critical('Cannot find intra-domain path for traffic %d.' % ev.traf_id)
                    return
                #Database.Data.insert_new_lsp(path, ev.resource_allocation)
                #Database.Data.intra_domain_path_list.pop_a_path(ev.traf_id, ev.route_type)
                #Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_SUCCESS) 
                if Database.Data.controller_list.is_this_domain(traf.domain_sequence[0]) != True:
                    result = SUCCESS
                    exit_of_previous_domain = list()
                    for path_item in paths:
                        new_path = Database.Data.intra_domain_path_list.find_a_path_by_id(path_item[0])
                        if new_path == None:
                            self.logger.critical('Cannot intra-domain path for traffic %d.' % ev.traf_id)
                            result = FAIL
                            break
                        Database.Data.insert_new_lsp(new_path, path_item[1])
                        print '?????????????????????????????=============='
                        print path_item[1]
                        exit_node_port_tmp = Database.Data.phy_topo.get_exit_of_previous_domain(new_path.route[0].node_ip, new_path.route[0].add_port_id)
                        if exit_node_port_tmp == None:
                            self.logger.critical('Can not find inter-domain link. (Path_computation: _handle_cross_domain_pc_request)')
                            result = FAIL
                            break
                        exit_tmp = [exit_node_port_tmp[0], exit_node_port_tmp[1], new_path.route_type, path_item[1]]
                        exit_of_previous_domain.append(exit_tmp)
                    Database.Data.intra_domain_path_list.pop_paths(ev.traf_id)
                    if result == SUCCESS:
                        Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_SUCCESS) 
                    else:
                        Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_FAIL)
                    pc_reply_ev = Custom_event.EastWest_SendPathCompReplyEvent()
                    pc_reply_ev.traf_id = ev.traf_id
                    pc_reply_ev.route_type = ev.route_type
                    pc_reply_ev.result = result
                    if result == SUCCESS:
                        pc_reply_ev.exit_of_previous_domain = exit_of_previous_domain
                    else:
                        pc_reply_ev.exit_of_previous_domain = None
                    self.send_event('EastWest_message_send', pc_reply_ev)
                else:
                    result = SUCCESS
                    for path_item in paths:
                        new_path = Database.Data.intra_domain_path_list.find_a_path_by_id(path_item[0])
                        if new_path == None:
                            self.logger.critical('Cannot intra-domain path for traffic %d.' % ev.traf_id)
                            result = FAIL
                            break
                        Database.Data.insert_new_lsp(new_path, ev.exit_of_this_domain[0][3])  
                        print '?????????????????????????-----------------'
                        print ev.exit_of_this_domain[0][3]
                    Database.Data.intra_domain_path_list.pop_paths(ev.traf_id)
                    if result == SUCCESS:
                        Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_SUCCESS) 
                    else:
                        Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_FAIL)
                    if ev.route_type == ROUTE_REROUTE:
                        rerouing_reply_ev = Custom_event.CrossDomainReroutingReplyEvent()
                        rerouing_reply_ev.traf_id = ev.traf_id
                        rerouing_reply_ev.result = result
                        self.send_event('Cross_domain_connection_ctrl', rerouing_reply_ev)
                    else:
                        pc_reply_ev = Custom_event.CrossDomainPathCompReplyEvent()
                        pc_reply_ev.traf_id = ev.traf_id
                        pc_reply_ev.result = result
                        self.send_event('Cross_domain_connection_ctrl', pc_reply_ev)
            else:   #FAIL or TIMEOUT
                self.logger.info('EastWest_ReceivePathCompReplyEvent result == FAIL or TIMEOUT')
                Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_FAIL) 
                Database.Data.intra_domain_path_list.pop_paths(ev.traf_id)
                if Database.Data.controller_list.is_this_domain(traf.domain_sequence[0]) != True:
                    pc_reply_ev = Custom_event.EastWest_SendPathCompReplyEvent()
                    pc_reply_ev.traf_id = ev.traf_id
                    pc_reply_ev.route_type = ev.route_type
                    pc_reply_ev.result = ev.result
                    pc_reply_ev.exit_of_previous_domain = None
                    self.send_event('EastWest_message_send', pc_reply_ev)
                else:
                    if ev.route_type == ROUTE_REROUTE:
                        rerouing_reply_ev = Custom_event.CrossDomainReroutingReplyEvent()
                        rerouing_reply_ev.traf_id = ev.traf_id
                        rerouing_reply_ev.result = ev.result
                        self.send_event('Cross_domain_connection_ctrl', rerouing_reply_ev)
                    else:
                        pc_reply_ev = Custom_event.CrossDomainPathCompReplyEvent()
                        pc_reply_ev.traf_id = ev.traf_id
                        pc_reply_ev.result = ev.result
                        self.send_event('Cross_domain_connection_ctrl', pc_reply_ev) 
        elif (traf.prot_type == TRAFFIC_1PLUS1_PROTECTION):
            pass
        else:
            self.logger.info('Protection type error! Protection type = %d' % ev.prot_type)
            

    @set_ev_cls(Custom_event.IntraDomainReroutingRequest)
    def _handle_intra_domain_rerouting_request(self,ev): 
        pass
        #rerouting
        #if SUCCESS:
        #   insert a new LSP to lsp_list
        #if traffic is intra-domain:
        #   send Custom_event.IntraDomainReroutingReply to 'Intra_domain_connection_ctrl'
        #elif traffic is cross-domain:
        #   send Custom_event.IntraDomainReroutingReply to 'Cross_domain_connection_ctrl'
        #else:
        #   error
        self.logger.debug('Path_computation module receives IntraDomainReroutingRequest')
        Database.Data.traf_list.update_traf_stage(ev.traf_id, TRAFFIC_REROUTING)
        Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_INTRA_DOMAIN_REROUTE)
        traf = Database.Data.traf_list.find_traf_by_id(ev.traf_id)
        if traf == None:
            self.logger.critcal('Cannot find traffic %d. (Path_computation: _handle_intra_domain_rerouting_request)' % ev.traf_id)
            return
        if traf.prot_type != TRAFFIC_REROUTING_RESTORATION:
            self.logger.critcal('Wrong protection type. (Path_computation: _handle_intra_domain_rerouting_request)')
            return
        for this_lsp in Database.Data.lsp_list.lsp_list:
            if this_lsp.traf_id == ev.traf_id and this_lsp.route_type == ROUTE_WORKING:
                #source_node_id = Database.Data.phy_topo.get_node_id_by_ip(this_lsp.explicit_route.route[0].node_ip)
                #destination_node_id = Database.Data.phy_topo.get_node_id_by_ip(this_lsp.explicit_route.route[-1].node_ip)
                sources = list()
                if traf.traf_type == TRAFFIC_INTRA_DOMAIN:
                    common_avai_chnls = Database.Data.phy_topo.get_traf_add_port_resouce(this_lsp.explicit_route.route[0].node_ip, this_lsp.explicit_route.route[0].add_port_id)
                elif traf.traf_type == TRAFFIC_CROSS_DOMAIN:
                    common_avai_chnls = list(this_lsp.occ_chnl)
                else:
                    self.logger.info('Invalid traffic type! (Path_computation: _handle_intra_domain_rerouting_request)')
                if common_avai_chnls == None:
                    self.logger.critical('Cannot find an add port. (Path_computation: _handle_intra_domain_rerouting_request)')
                    return
                sources.append([this_lsp.explicit_route.route[0].node_ip, this_lsp.explicit_route.route[0].add_port_id, ROUTE_INTRA_REROUTE, 0, common_avai_chnls])
                destinations = list()
                destinations.append([this_lsp.explicit_route.route[-1].node_ip, this_lsp.explicit_route.route[-1].drop_port_id])
                paths = RWA.rerouting(ev.traf_id, sources, destinations, traf.bw_demand)
                if paths == None:
                    reroute_reply_ev = Custom_event.IntraDomainReroutingReply()
                    reroute_reply_ev.traf_id = ev.traf_id
                    reroute_reply_ev.result = FAIL
                    if traf.traf_type == TRAFFIC_INTRA_DOMAIN:
                        self.send_event('Intra_domain_connection_ctrl', reroute_reply_ev)
                    elif traf.traf_type == TRAFFIC_CROSS_DOMAIN:
                        self.send_event('Cross_domain_connection_ctrl', reroute_reply_ev)
                    else:
                        self.logger.info('Invalid traffic type! (Path_computation: _handle_intra_domain_rerouting_request)')
                else:
                    result = SUCCESS
                    for path in paths:
                        Database.Data.intra_domain_path_list.insert_a_new_path(path)    #record the result of routing
                    resources = RWA.rsc_allocation(ev.traf_id, traf.bw_dmd)
                    for path_item in resources:
                        new_path = Database.Data.intra_domain_path_list.find_a_path_by_id(path_item[0])
                        if new_path == None:
                            self.logger.critical('Cannot intra-domain path for traffic %d.' % ev.traf_id)
                            result = FAIL
                            break
                        if new_path.route_type == ROUTE_INTRA_REROUTE:
                            Database.Data.insert_new_lsp(new_path, path_item[1])
                        else:
                            self.logger.critical('Wrong route type. (Path_computation: _handle_intra_domain_rerouting_request)')
                            return
                    Database.Data.intra_domain_path_list.pop_paths(ev.traf_id)
                    if result == SUCCESS:
                        Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_INTRA_DOMAIN_REROUTE_SUCCESS) 
                    else:
                        Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_INTRA_DOMAIN_REROUTE_FAIL)
                    reroute_reply_ev = Custom_event.IntraDomainReroutingReply()
                    reroute_reply_ev.traf_id = ev.traf_id
                    reroute_reply_ev.result = result
                    if traf.traf_type == TRAFFIC_INTRA_DOMAIN:
                        self.send_event('Intra_domain_connection_ctrl', reroute_reply_ev)
                    elif traf.traf_type == TRAFFIC_CROSS_DOMAIN:
                        self.send_event('Cross_domain_connection_ctrl', reroute_reply_ev)
                    else:
                        self.logger.info('Invalid traffic type! (Path_computation: _handle_intra_domain_rerouting_request)')

        '''# from Yiwen
        if Database.Data.controller_list.is_this_domain(traf.domain_sequence[0]) == True:
            src_node_ip = traf.src_node_ip
            src_port_id = Database.Data.phy_topo.get_port_id(src_node_ip)
            edge_node_ip = Database.Data.phy_topo.get_edge_node_ip()
            edge_node_id = Database.Data.phy_topo.get_edge_node_id()
        else:
            src_node_ip = Database.Data.phy_topo.get_edge_node_ip()
            src_port_id = Database.Data.phy_topo.get_edge_node_id()
            edge_node_ip = traf.dst_node_ip
            edge_node_id = Database.Data.phy_topo.get_port_id(edge_node_ip)
            self.logger.info ("Begin path computation in source domain from source node {0} to edge node {1}".format(src_node_ip, edge_node_ip))
            topo = Database.Data.phy_topo.get_topo()
               
            nlambda = 3
            paths = self.routing(str(ev.traf_id), topo, nlambda, src_node_ip, src_port_id, edge_node_ip, traf.bw_dmd)    #routing. calculate one path
        # from Yiwen end'''

        '''path = list()
        if Database.Data.controller_list.is_this_domain(traf.domain_sequence[0]) == True:
            path = []
        else:
            path.append(ev.traf_id)
            path.append(ROUTE_INTRA_REROUTE)
            path.append(0)
            path.append([['192.168.2.1',1,3],['192.168.2.2',1,2],['192.168.2.3',2,3]])
            path.append([15])
            resources = [15]
        Database.Data.intra_domain_path_list.insert_a_new_path(path)
        path = Database.Data.intra_domain_path_list.find_a_path(ev.traf_id, ROUTE_INTRA_REROUTE)
        Database.Data.insert_new_lsp(path, resources)
        rerouting_reply_ev = Custom_event.IntraDomainReroutingReply()
        rerouting_reply_ev.traf_id = ev.traf_id
        if path != []:
            rerouting_reply_ev.result = SUCCESS
        else:
            rerouting_reply_ev.result = FAIL
        traf = Database.Data.traf_list.find_traf_by_id(ev.traf_id)
        if traf.traf_type == TRAFFIC_INTRA_DOMAIN:
            self.send_event('Intra_domain_connection_ctrl', rerouting_reply_ev)
        elif traf.traf_type == TRAFFIC_CROSS_DOMAIN:
            self.send_event('Cross_domain_connection_ctrl', rerouting_reply_ev)
        else:
            self.logger.info('Invalid traffic type! (Path_computation: _handle_intra_domain_rerouting_request)')'''
            
        
    @set_ev_cls(Custom_event.CrossDomainReroutingRequestEvent)
    def _handle_cross_domain_rerouting_request(self,ev):
        pass
        #update traffic stage to TRAFFIC_REROUTING
        #reroute at this first domain
        #if SUCCESS:
        #   update traffic state to TRAFFIC_PATH_COMPUTATION
        #   send Custom_event.EastWest_SendPathCompRequestEvent to 'EastWest_message_send'
        #else:
        #   update traffic state to TRAFFIC_PATH_COMPUTATION_FAIL
        #   send Custom_event.CrossDomainReroutingReplyEvent to 'Cross_domain_connection_ctrl'
        Database.Data.traf_list.update_traf_stage(ev.traf_id, TRAFFIC_REROUTING)
        Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION)
        traf = Database.Data.traf_list.find_traf_by_id(ev.traf_id)
        if (traf == None):
            self.logger.critical('Can not find traf_id in database! (cross_domain_reroute_at_src_domain)')
            return
        if traf.prot_type != TRAFFIC_REROUTING_RESTORATION:
            self.logger.critcal('Wrong protection type. (Path_computation: _handle_intra_domain_rerouting_request)')
            return
 
        sources = list()
        traf_add_port_id = Database.Data.phy_topo.get_traf_add_port(traf.src_node_ip)
        if traf_add_port_id == None:
            self.logger.critical('Cannot find an add port. (Path_computation: _handle_cross_domain_traffic_pc_request)')
            return
        common_avai_chnls = Database.Data.phy_topo.get_traf_add_port_resouce(traf.src_node_ip, traf_add_port_id)
        if common_avai_chnls == None:
            self.logger.critical('Cannot find an add port. (Path_computation: _handle_cross_domain_traffic_pc_request)')
            return
        sources.append([traf.src_node_ip, traf_add_port_id, ROUTE_WORKING, 0, common_avai_chnls])
        destinations = RWA.find_exit_of_this_domain(traf.domain_sequence[1])
        if destinations == None:
            self.logger.critical('Cannot find a interlink. (Path_computation: _handle_cross_domain_traffic_pc_request)')
            return
        paths = RWA.rerouting(ev.traf_id, sources, destinations, traf.bw_demand)    #routing. calculate one path

        if paths == None:
            # send pc reply event to Cross_domain_connection_ctrl
            pc_reply_ev = Custom_event.CrossDomainReroutingReplyEvent()
            pc_reply_ev.traf_id = traf.traf_id
            pc_reply_ev.result = FAIL
            self.send_event('Cross_domain_connection_ctrl', pc_reply_ev)
        else:
            for path in paths:                    
                Database.Data.intra_domain_path_list.insert_a_new_path(path)    #record the result of routing
            entry_of_next_domain = RWA.find_entry_of_next_domain(ev.traf_id)  # find entry of next domain
            if entry_of_next_domain != None:
                cross_domain_pc_ev = Custom_event.EastWest_SendPathCompRequestEvent()
                cross_domain_pc_ev.traf_id = ev.traf_id
                cross_domain_pc_ev.route_type = ROUTE_REROUTE
                cross_domain_pc_ev.entry_of_next_domain = entry_of_next_domain
                self.send_event('EastWest_message_send',cross_domain_pc_ev)
            else:
                pc_reply_ev = Custom_event.CrossDomainReroutingReplyEvent()
                pc_reply_ev.traf_id = traf.traf_id
                pc_reply_ev.result = FAIL
                self.send_event('Cross_domain_connection_ctrl', pc_reply_ev)
                
            '''# from Yiwen
            src_node_ip = traf.src_node_ip
            src_port_id = Database.Data.phy_topo.get_port_id(src_node_ip)
            edge_node_ip = Database.Data.phy_topo.get_edge_node_ip()
            edge_node_id = Database.Data.phy_topo.get_edge_node_id()
            self.logger.info ("Begin path computation in source domain from source node {0} to edge node {1}".format(src_node_ip, edge_node_ip))
            topo = Database.Data.phy_topo.get_topo()
           
            nlambda = 3
            paths = self.routing(str(ev.traf_id), topo, nlambda, src_node_ip, src_port_id, edge_node_ip, traf.bw_dmd)    #routing. calculate one path
            # from Yiwen end'''

        '''Database.Data.traf_list.update_traf_stage(ev.traf_id, TRAFFIC_REROUTING)
        path = list()
        path.append(ev.traf_id)
        path.append(ROUTE_REROUTE)
        path.append(0)
        path.append([['192.168.1.1',1,2],['192.168.1.2',1,2],['192.168.1.3',1,2]])
        path.append([30])
        Database.Data.intra_domain_path_list.insert_a_new_path(path)
        if path != []:
            Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION)
            #entry_of_next_domain = Database.Data.find_entry_of_next_domain(ev.traf_id)  # find entry of next domain
            entry_of_next_domain = []
            pc_req_ev = Custom_event.EastWest_SendPathCompRequestEvent()
            pc_req_ev.traf_id = ev.traf_id
            pc_req_ev.route_type = ROUTE_REROUTE
            pc_req_ev.entry_of_next_domain = entry_of_next_domain
            self.send_event('EastWest_message_send',pc_req_ev)
            #setup a timer for cross-domain path computation. Moved to EastWest_message_send 
            #new_timer = Timer()
            #new_timer.traf_id = ev.traf_id
            #new_timer.timer_type = TIMER_PATH_COMPUTATION
            #new_timer.end_time = time.time() + EASTWEST_WAITING_TIME
            #eastwest_timer.append(new_timer)
        else:
            Database.Data.traf_list.update_traf_state(ev.traf_id, TRAFFIC_PATH_COMPUTATION_FAIL)
            rerouing_replt_ev = Custom_event.CrossDomainReroutingReplyEvent()
            rerouing_replt_ev.traf_id = ev.traf_id
            rerouing_replt_ev.result = FAIL
            self.send_event('Cross_domain_connection_ctrl', rerouing_replt_ev)'''
            
    
        
        
    #def routing(self, source_node_id, src_port_id, destination_node_id, bw_demand):
        """input: src_node_id, src_port_id, dst_node_id, bw_demand
           output: (traf_id, route_type, cost, route(a tuple of (node_ip, add_port_id, drop_port_id)), common_avai_chnl). if fail, return None
        """
        #pass

    #from Yiwen   modified by Yao 2017-05-03
    def routing_yiwen(self, traf_id, topo, nlambda, src_node_ip, src_port_id, edge_node_ip, bw_demand):
        """input: src_node_id, src_port_id, dst_node_id, bw_demand
           output: [traf_id, route_type, cost, route(a list of node_id), common_avai_chnl]. if fail, return []
        """
        #self.logger.info (traf_id, topo, nlambda, src_node_ip, edge_node_ip)
        computed_path = path_wav_compute(traf_id, topo, nlambda, src_node_ip, edge_node_ip)
        #print (computed_path)

        routes=[]
        wavelengths=[]
        for i in range(len(computed_path)):
            routes.append(computed_path[i][0])
            wavelengths.append(computed_path[i][1])

        # translate ips to ids in computed path
        #for i in range(0, len(computed_path[0])):
        #    route.append(Database.Data.phy_topo.get_node_id_by_ip(computed_path[0][i]))
        

        return [traf_id, ROUTE_WORKING, 0, routes, wavelengths]
    #from Yiwen end
        

    #def rsc_allocation(self, comm_avai_chnl, bw_demand):
        """input: comm_avai_chnl(a list), bw_demand
           output: resources (a list)
        """
        #pass
        #return a_list
    
    def handle_osnr_estimation(self, selected_path):
        self.flow_id = self.flow_id + 1
        flows_osnr = {}
        flows_osnr[self.flow_id] = []
        power = 1
        noise = 1e-10
        print('handle_osnr_estimation: ')
        print(len(selected_path))
        LEN_PATH = len(selected_path)
        NODE_FLAG = 1
        for node in selected_path:
            input_power, input_noise = self.estimate_input_power_noise(power, noise)
            output_power, output_noise = self.estimate_output_power_noise(input_power, input_noise)
            osnr = output_power / output_noise
            flows_osnr[self.flow_id].append(osnr)
            power = output_power
            noise = output_noise
            if NODE_FLAG == LEN_PATH-1:
                self.abs_fiber_loss = self.dB_to_abs(1e-10)
                # Converting 18dB loss (Two WSS)
                self.abs_WSS_loss = self.dB_to_abs(9)
                sleep(0.01)
            else:
                self.abs_fiber_loss = self.dB_to_abs(0.2*60)
                # Converting 18dB loss (Two WSS)
                self.abs_WSS_loss = self.dB_to_abs(18)
                sleep(0.01)
            NODE_FLAG = NODE_FLAG + 1
                    
        f = open("rwa_osnr.log","a+")
        f.write(str(flows_osnr) + "\n")
        print flows_osnr
        f.close()
        self.abs_fiber_loss = self.dB_to_abs(0.2*60)
        # Converting 6dB loss
        self.abs_WSS_loss = self.dB_to_abs(9) # constant
        
        return flows_osnr[self.flow_id][-1]
        
    def estimate_input_power_noise(self, in_signal_power, noise):
        in_power = (in_signal_power / self.abs_fiber_loss / self.abs_WSS_loss)
        in_noise = (noise / self.abs_fiber_loss / self.abs_WSS_loss)
        return in_power, in_noise

    def estimate_output_power_noise(self, input_power, input_noise):
        sys_gain = self._ripple_function()

        out_power = input_power * sys_gain
        out_noise = self.calculate_out_noise(input_noise, 1, sys_gain)

        return out_power, out_noise

    def _ripple_function(self):
        try:
            #ripple_lambda = 1.00111792183 #Average from ripple function
            ripple_lambda = 1.0 #Average from ripple function
            target_gain = self.abs_fiber_loss * self.abs_WSS_loss
            sys_gain = ripple_lambda * target_gain
            return float(sys_gain)
        except:
            return float(self.abs_fiber_loss * self.abs_WSS_loss)

    def calculate_out_noise(self, input_noise, n_lambda, sys_gain):
        planck_const = sc.h # 6.62607004e-34
        speed_of_light = sc.speed_of_light # 299792458.0
        c_band_lambda = (1549+n_lambda)*(10**-9) # m
        noise_figure = 10**(6/float(10))
        bandwidth = 12.5*(10**9) # Considering 50GHz bandwidth
        watt_to_mwatt = 1000
        out_noise = ((input_noise * sys_gain) + ((planck_const*(speed_of_light/c_band_lambda)) * watt_to_mwatt * sys_gain * noise_figure * bandwidth))
        return out_noise

    def remote_mininet_client(self, flow_id, src_node_id, dest_node_id, wavelength):
        file_path = 'remote_mininet_client/' + str(flow_id)
        line = str(flow_id) + " " + str(src_node_id) + " " + str(dest_node_id) + " " + str(wavelength)
        f = open(file_path, 'w+')
        f.write(line)
        f.close()
    
    def dB_to_abs(self, value):
        absolute_value = 10**(value/float(10))
        return absolute_value